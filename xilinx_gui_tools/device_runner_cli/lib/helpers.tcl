# Device Runner CLI Helper Functions
# Command line interface helper functions

namespace eval DeviceRunnerCLI {
    
    # Log message with timestamp
    proc log_message {message {log_file ""}} {
        if {$log_file == ""} {
            set log_file [file join "output" "device_runner_cli.log"]
        }
        
        set timestamp [clock format [clock seconds] -format "%Y-%m-%d %H:%M:%S"]
        set fp [open $log_file a]
        puts $fp "$timestamp - $message"
        close $fp
    }
    
    # Validate integer parameters
    proc validate_integer_params {param1 param2 param3} {
        # Validate parameter 1 (menu selection)
        if {$param1 == ""} {
            puts "ERROR: Parameter 1 not configured"
            return 1
        }
        
        if {![regexp {^0x[0-9A-Fa-f]{1,8}$} $param1]} {
            puts "ERROR: Parameter 1 has invalid format: $param1"
            return 1
        }
        
        # Validate parameter 2 (if provided)
        if {$param2 != "" && ![regexp {^0x[0-9A-Fa-f]{1,8}$} $param2]} {
            puts "ERROR: Parameter 2 has invalid format: $param2"
            return 1
        }
        
        # Validate parameter 3 (if provided)
        if {$param3 != "" && ![regexp {^0x[0-9A-Fa-f]{1,8}$} $param3]} {
            puts "ERROR: Parameter 3 has invalid format: $param3"
            return 1
        }
        
        return 0
    }
    
    # Format integer parameters
    proc format_integer_params {param1 param2 param3} {
        set result ""
        
        if {$param1 != ""} {
            append result $param1
        }
        
        if {$param2 != ""} {
            if {$result != ""} {
                append result " "
            }
            append result $param2
        }
        
        if {$param3 != ""} {
            if {$result != ""} {
                append result " "
            }
            append result $param3
        }
        
        return $result
    }
    
    # Format hex 32-bit
    proc format_hex_32bit {param} {
        # Remove 0x prefix if present
        set hex_value [string trimleft $param "0x"]
        
        # Ensure it doesn't exceed 8 digits
        if {[string length $hex_value] > 8} {
            set hex_value [string range $hex_value end-7 end]
        }
        
        return "0x$hex_value"
    }
    
    # Get timestamp for filenames
    proc get_timestamp {} {
        return [clock format [clock seconds] -format "%Y%m%d_%H%M%S"]
    }
    
    # Run application
    proc run_application {app_path args output_dir} {
        log_message "Running application: $app_path with args: $args"
        
        puts "Executing: $app_path $args"
        
        if {[catch {eval exec $app_path {*}$args} result]} {
            puts "ERROR: Application execution failed: $result"
            log_message "ERROR: Application execution failed: $result"
            return 1
        } else {
            puts "Application output:"
            puts $result
            log_message "Application completed successfully"
            return 0
        }
    }
    
    # Program FPGA with BIT file
    proc program_fpga_jtag {bit_file file_type output_dir {xsdb_path ""} {jtag_tcp ""}} {
        log_message "Programming FPGA with $file_type file: $bit_file"
        
        # Create TCL script for BIT programming
        set tcl_script [file join $output_dir "program_bit.tcl"]
        set fp [open $tcl_script w]
        
        puts $fp "# BIT Programming Script"
        puts $fp "# Generated by Device Runner CLI"
        puts $fp "# Timestamp: [clock format [clock seconds] -format "%Y-%m-%d %H:%M:%S"]"
        puts $fp ""
        
        # Add JTAG TCP configuration if provided
        if {$jtag_tcp != ""} {
            puts $fp "# Configure JTAG TCP connection"
            puts $fp "connect -url $jtag_tcp"
            puts $fp ""
        } else {
            puts $fp "# Connect to target"
            puts $fp "connect"
            puts $fp ""
        }
        
        puts $fp "# Set target to processor"
        puts $fp "targets -set -filter {name =~ \"PS*\"}"
        puts $fp ""
        puts $fp "# Program FPGA with BIT file"
        puts $fp "fpga -file \"$bit_file\""
        puts $fp ""
        puts $fp "puts \"BIT file programming completed successfully\""
        
        close $fp
        
        log_message "Created BIT programming script: $tcl_script"
        
        # Try to execute the script
        set cmd [expr {$xsdb_path != "" ? $xsdb_path : "xsct"}]
        log_message "Executing: $cmd $tcl_script"
        
        if {[catch {eval exec $cmd $tcl_script} result]} {
            puts "ERROR executing $cmd: $result"
            log_message "ERROR executing $cmd: $result"
            return 1
        } else {
            puts "XSCT/XSDB output:"
            puts $result
            log_message "BIT programming completed successfully"
            return 0
        }
    }
    
    # Capture RAM data
    proc capture_ram_data {output_dir {xsdb_path ""} {jtag_tcp ""} {param1 ""} {param2 ""} {param3 ""}} {
        log_message "Capturing RAM data from device..."
        
        # Create capture directory with timestamp
        set timestamp [get_timestamp]
        set capture_dir [file join $output_dir "capture_$timestamp"]
        file mkdir $capture_dir
        
        log_message "Created capture directory: $capture_dir"
        
        # Save user inputs to capture directory
        set inputs_file [file join $capture_dir "user_inputs.txt"]
        set fp [open $inputs_file w]
        puts $fp "User Input Parameters"
        puts $fp "===================="
        puts $fp "Timestamp: [clock format [clock seconds] -format "%Y-%m-%d %H:%M:%S"]"
        puts $fp ""
        puts $fp "Parameter 1: $param1"
        puts $fp "Parameter 2: $param2"
        puts $fp "Parameter 3: $param3"
        puts $fp ""
        puts $fp "Formatted Parameters:"
        set formatted_params [format_integer_params $param1 $param2 $param3]
        puts $fp "  $formatted_params"
        puts $fp ""
        puts $fp "Parameter Details:"
        if {$param1 != ""} {
            puts $fp "  Parameter 1: $param1 (hex: [format_hex_32bit $param1])"
        }
        if {$param2 != ""} {
            puts $fp "  Parameter 2: $param2 (hex: [format_hex_32bit $param2])"
        }
        if {$param3 != ""} {
            puts $fp "  Parameter 3: $param3 (hex: [format_hex_32bit $param3])"
        }
        close $fp
        
        log_message "Saved user inputs to: $inputs_file"
        
        # Create TCL script for RAM data capture
        set tcl_script [file join $capture_dir "capture_ram.tcl"]
        set fp [open $tcl_script w]
        
        puts $fp "# RAM Data Capture Script"
        puts $fp "# Generated by Device Runner CLI"
        puts $fp "# Timestamp: [clock format [clock seconds] -format "%Y-%m-%d %H:%M:%S"]"
        puts $fp "# User Parameters: $formatted_params"
        puts $fp ""
        
        # Add JTAG TCP configuration if provided
        if {$jtag_tcp != ""} {
            puts $fp "# Configure JTAG TCP connection"
            puts $fp "connect -url $jtag_tcp"
            puts $fp ""
        } else {
            puts $fp "# Connect to target"
            puts $fp "connect"
            puts $fp ""
        }
        
        puts $fp "# Set target to processor"
        puts $fp "targets -set -filter {name =~ \"PS*\"}"
        puts $fp ""
        puts $fp "# Stop processor to access memory"
        puts $fp "stop"
        puts $fp ""
        puts $fp "# Define memory regions to capture"
        puts $fp "set memory_regions {"
        puts $fp "    {0x00000000 0x00010000 \"DDR_START\"}"
        puts $fp "    {0x00010000 0x00010000 \"DDR_LOW\"}"
        puts $fp "    {0x00020000 0x00010000 \"DDR_MID_LOW\"}"
        puts $fp "    {0x00030000 0x00010000 \"DDR_MID\"}"
        puts $fp "    {0x00040000 0x00010000 \"DDR_MID_HIGH\"}"
        puts $fp "    {0x00050000 0x00010000 \"DDR_HIGH\"}"
        puts $fp "    {0x00100000 0x00010000 \"APP_DATA\"}"
        puts $fp "    {0x00110000 0x00010000 \"APP_STACK\"}"
        puts $fp "    {0x00120000 0x00020000 \"APP_HEAP\"}"
        puts $fp "    {0x00140000 0x00020000 \"APP_ARRAYS\"}"
        puts $fp "    {0x00160000 0x00020000 \"APP_OUTPUT\"}"
        puts $fp "    {0x00180000 0x00010000 \"APP_CONFIG\"}"
        puts $fp "    {0x40000000 0x00001000 \"GPIO_REGION\"}"
        puts $fp "    {0x43C00000 0x00001000 \"AXI_REGION\"}"
        puts $fp "    {0xE0000000 0x00010000 \"PS_PERIPHERALS\"}"
        puts $fp "}"
        puts $fp ""
        puts $fp "# Capture each memory region"
        puts $fp "foreach region \$memory_regions {"
        puts $fp "    set start_addr [lindex \$region 0]"
        puts $fp "    set size [lindex \$region 1]"
        puts $fp "    set name [lindex \$region 2]"
        puts $fp "    "
        puts $fp "    puts \"Capturing \$name at \$start_addr (size: \$size)\""
        puts $fp "    "
        puts $fp "    # Read memory data"
        puts $fp "    set data \[mrd \$start_addr \$size\]"
        puts $fp "    "
        puts $fp "    # Save to file"
        puts $fp "    set filename \"\$name\_\$start_addr.bin\""
        puts $fp "    set fp \[open \$filename w\]"
        puts $fp "    puts \$fp \$data"
        puts $fp "    close \$fp"
        puts $fp "    "
        puts $fp "    puts \"Saved \$filename\""
        puts $fp "}"
        puts $fp ""
        puts $fp "# Resume processor"
        puts $fp "resume"
        puts $fp ""
        puts $fp "puts \"RAM data capture completed successfully\""
        
        close $fp
        
        log_message "Created RAM capture script: $tcl_script"
        
        # Try to execute the script
        set cmd [expr {$xsdb_path != "" ? $xsdb_path : "xsct"}]
        log_message "Executing: $cmd $tcl_script"
        
        if {[catch {eval exec $cmd $tcl_script} result]} {
            puts "ERROR executing $cmd: $result"
            log_message "ERROR executing $cmd: $result"
            return 1
        } else {
            puts "XSCT/XSDB output:"
            puts $result
            log_message "RAM data capture completed successfully"
            return 0
        }
    }
    
    # Wait for data ready signal via polling
    proc wait_for_data_ready {output_dir {xsdb_path ""} {jtag_tcp ""}} {
        log_message "Starting data ready polling..."
        
        # Create TCL script for data ready polling
        set tcl_script [file join $output_dir "poll_data_ready.tcl"]
        set fp [open $tcl_script w]
        
        puts $fp "# Data Ready Polling Script"
        puts $fp "# Generated by Device Runner CLI"
        puts $fp "# Timestamp: [clock format [clock seconds] -format "%Y-%m-%d %H:%M:%S"]"
        puts $fp ""
        
        # Add JTAG TCP configuration if provided
        if {$jtag_tcp != ""} {
            puts $fp "# Configure JTAG TCP connection"
            puts $fp "connect -url $jtag_tcp"
            puts $fp ""
        } else {
            puts $fp "# Connect to target"
            puts $fp "connect"
            puts $fp ""
        }
        
        puts $fp "# Set target to processor"
        puts $fp "targets -set -filter {name =~ \"PS*\"}"
        puts $fp ""
        puts $fp "# Define data ready signal locations"
        puts $fp "set data_ready_addresses {"
        puts $fp "    0x00100000  # Global status register"
        puts $fp "    0x00100004  # Data ready flag"
        puts $fp "    0x00100008  # Processing complete flag"
        puts $fp "    0x0010000C  # Error status flag"
        puts $fp "}"
        puts $fp ""
        puts $fp "# Polling configuration"
        puts $fp "set max_polls 100"
        puts $fp "set poll_interval 100"
        puts $fp "set data_ready_value 0x00000001"
        puts $fp ""
        puts $fp "puts \"Starting data ready polling...\""
        puts $fp "puts \"Polling addresses: \$data_ready_addresses\""
        puts $fp "puts \"Looking for value: \$data_ready_value\""
        puts $fp "puts \"Max polls: \$max_polls, Interval: \$poll_interval ms\""
        puts $fp ""
        puts $fp "# Polling loop"
        puts $fp "for {set poll_count 0} {\$poll_count < \$max_polls} {incr poll_count} {"
        puts $fp "    puts \"Poll \$poll_count: Checking data ready signals...\""
        puts $fp "    "
        puts $fp "    set data_ready_found 0"
        puts $fp "    foreach addr \$data_ready_addresses {"
        puts $fp "        set value \[mrd \$addr 4\]"
        puts $fp "        puts \"  Address 0x\[format %08X \$addr\]: 0x\$value\""
        puts $fp "        "
        puts $fp "        if {\$value == \$data_ready_value} {"
        puts $fp "            puts \"  Data ready signal found at 0x\[format %08X \$addr\]!\""
        puts $fp "            set data_ready_found 1"
        puts $fp "            break"
        puts $fp "        }"
        puts $fp "    }"
        puts $fp "    "
        puts $fp "    if {\$data_ready_found} {"
        puts $fp "        puts \"Data ready signal detected after \$poll_count polls\""
        puts $fp "        puts \"Data is ready for capture\""
        puts $fp "        break"
        puts $fp "    }"
        puts $fp "    "
        puts $fp "    puts \"Data not ready, waiting \$poll_interval ms...\""
        puts $fp "    after \$poll_interval"
        puts $fp "}"
        puts $fp ""
        puts $fp "if {\$poll_count >= \$max_polls} {"
        puts $fp "    puts \"ERROR: Data ready signal not detected after \$max_polls polls\""
        puts $fp "    puts \"Timeout waiting for data ready signal\""
        puts $fp "    exit 1"
        puts $fp "} else {"
        puts $fp "    puts \"Data ready polling completed successfully\""
        puts $fp "    exit 0"
        puts $fp "}"
        
        close $fp
        
        log_message "Created data ready polling script: $tcl_script"
        
        # Try to execute the script
        set cmd [expr {$xsdb_path != "" ? $xsdb_path : "xsct"}]
        log_message "Executing: $cmd $tcl_script"
        
        if {[catch {eval exec $cmd $tcl_script} result]} {
            puts "ERROR executing $cmd: $result"
            log_message "ERROR executing $cmd: $result"
            return 1
        } else {
            puts "XSCT/XSDB output:"
            puts $result
            log_message "Data ready polling completed successfully"
            return 0
        }
    }
}

