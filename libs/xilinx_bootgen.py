#!/usr/bin/env python3
"""
Xilinx Bootgen Utility Library

This library provides functionality for generating boot.bin files using
Xilinx's bootgen tool. It supports various boot image formats and
configurations for different Xilinx devices.

Key Features:
- Boot image generation using bootgen
- Support for multiple boot components (FSBL, bitstream, ELF, etc.)
- Configuration file management
- Integration with Vivado projects
- Path management for Xilinx tools

Author: Automated Test Framework
Version: 1.0.0
"""

import os
import subprocess
import json
import logging
import tempfile
from pathlib import Path
from typing import List, Dict, Optional, Any, Tuple
from dataclasses import dataclass
from enum import Enum


class BootComponentType(Enum):
    """Enumeration of boot component types."""
    FSBL = "fsbl"
    BITSTREAM = "bitstream"
    ELF = "elf"
    DATA_FILE = "datafile"
    PMUFW = "pmufw"
    ATF = "atf"
    UBOOT = "uboot"


@dataclass
class BootComponent:
    """Data class representing a boot component."""
    name: str
    component_type: BootComponentType
    file_path: str
    load_address: Optional[str] = None
    execution_address: Optional[str] = None
    attributes: Optional[Dict[str, Any]] = None


@dataclass
class BootgenConfig:
    """Configuration for bootgen operations."""
    output_file: str
    components: List[BootComponent]
    boot_mode: str = "sd"
    arch: str = "zynqmp"
    boot_device: str = "sd0"
    bootgen_path: Optional[str] = None
    verbose: bool = False


class BootgenError(Exception):
    """Custom exception for bootgen-related errors."""
    pass


class XilinxBootgen:
    """
    Main class for bootgen operations.
    
    This class provides functionality for generating boot images using
    Xilinx's bootgen tool. It supports various boot configurations and
    integrates with the existing test framework.
    """
    
    def __init__(self, config: Optional[BootgenConfig] = None):
        """
        Initialize the bootgen utility.
        
        Args:
            config: Bootgen configuration object
        """
        self.config = config or BootgenConfig(output_file="boot.bin", components=[])
        self.logger = logging.getLogger(__name__)
    
    def _find_bootgen_executable(self) -> str:
        """
        Find the bootgen executable.
        
        Returns:
            Path to the bootgen executable
            
        Raises:
            BootgenError: If bootgen cannot be found
        """
        if self.config.bootgen_path:
            if os.path.exists(self.config.bootgen_path):
                return self.config.bootgen_path
            else:
                raise BootgenError(f"Specified bootgen path not found: {self.config.bootgen_path}")
        
        # Common installation paths for bootgen
        common_paths = [
            # Windows paths
            r"C:\Xilinx\Vitis\*\bin\bootgen.exe",
            r"C:\Xilinx\SDK\*\bin\bootgen.exe",
            r"C:\Xilinx\Vivado\*\bin\bootgen.exe",
            # Linux paths
            "/opt/Xilinx/Vitis/*/bin/bootgen",
            "/opt/Xilinx/SDK/*/bin/bootgen",
            "/opt/Xilinx/Vivado/*/bin/bootgen",
            # Generic paths
            "bootgen"
        ]
        
        for path_pattern in common_paths:
            if "*" in path_pattern:
                # Handle wildcard paths
                import glob
                matches = glob.glob(path_pattern)
                if matches:
                    return matches[0]  # Use the first match
            else:
                # Check if executable exists in PATH
                try:
                    result = subprocess.run(
                        ["which", path_pattern] if os.name != "nt" else ["where", path_pattern],
                        capture_output=True,
                        text=True,
                        timeout=5
                    )
                    if result.returncode == 0:
                        return path_pattern
                except (subprocess.TimeoutExpired, FileNotFoundError):
                    continue
        
        raise BootgenError(
            "Could not find bootgen executable. "
            "Please ensure Xilinx tools are installed and in PATH, "
            "or specify the bootgen path in configuration."
        )
    
    def _generate_bif_file(self, bif_file_path: str) -> str:
        """
        Generate a Boot Image Format (BIF) file.
        
        Args:
            bif_file_path: Path where to save the BIF file
            
        Returns:
            Path to the generated BIF file
        """
        try:
            with open(bif_file_path, 'w') as f:
                f.write(f"// Boot Image Format (BIF) file\n")
                f.write(f"// Generated by Xilinx Bootgen Utility\n\n")
                
                f.write(f"the_ROM_image:\n")
                f.write(f"{{\n")
                f.write(f"    [bootloader]{self.config.components[0].file_path}\n")
                
                # Write other components
                for i, component in enumerate(self.config.components[1:], 1):
                    f.write(f"    {component.file_path}")
                    
                    if component.load_address:
                        f.write(f" load {component.load_address}")
                    
                    if component.execution_address:
                        f.write(f" exec {component.execution_address}")
                    
                    f.write(f"\n")
                
                f.write(f"}}\n")
            
            self.logger.debug(f"Generated BIF file: {bif_file_path}")
            return bif_file_path
            
        except Exception as e:
            raise BootgenError(f"Failed to generate BIF file: {e}")
    
    def generate_boot_image(self) -> bool:
        """
        Generate boot image using bootgen.
        
        Returns:
            True if generation successful, False otherwise
        """
        try:
            if not self.config.components:
                raise BootgenError("No boot components specified")
            
            # Find bootgen executable
            bootgen_path = self._find_bootgen_executable()
            self.logger.info(f"Using bootgen: {bootgen_path}")
            
            # Create temporary BIF file
            with tempfile.NamedTemporaryFile(mode='w', suffix='.bif', delete=False) as bif_file:
                bif_file_path = bif_file.name
                self._generate_bif_file(bif_file_path)
            
            try:
                # Build bootgen command
                cmd = [
                    bootgen_path,
                    "-image", bif_file_path,
                    "-arch", self.config.arch,
                    "-o", self.config.output_file
                ]
                
                if self.config.verbose:
                    cmd.append("-verbose")
                
                self.logger.info(f"Running bootgen command: {' '.join(cmd)}")
                
                # Execute bootgen
                result = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    timeout=60
                )
                
                if result.returncode == 0:
                    self.logger.info(f"Boot image generated successfully: {self.config.output_file}")
                    return True
                else:
                    self.logger.error(f"Bootgen failed: {result.stderr}")
                    return False
                    
            finally:
                # Clean up temporary BIF file
                try:
                    os.unlink(bif_file_path)
                except:
                    pass
            
        except Exception as e:
            self.logger.error(f"Error generating boot image: {e}")
            return False
    
    def create_fsbl_boot_image(self, fsbl_path: str, bitstream_path: str, 
                              output_path: str = "boot.bin") -> bool:
        """
        Create a simple FSBL boot image.
        
        Args:
            fsbl_path: Path to FSBL ELF file
            bitstream_path: Path to bitstream file
            output_path: Output boot image path
            
        Returns:
            True if successful, False otherwise
        """
        try:
            # Verify input files exist
            if not os.path.exists(fsbl_path):
                raise BootgenError(f"FSBL file not found: {fsbl_path}")
            
            if not os.path.exists(bitstream_path):
                raise BootgenError(f"Bitstream file not found: {bitstream_path}")
            
            # Create components
            components = [
                BootComponent("fsbl", BootComponentType.FSBL, fsbl_path),
                BootComponent("bitstream", BootComponentType.BITSTREAM, bitstream_path)
            ]
            
            # Update config
            self.config.output_file = output_path
            self.config.components = components
            
            # Generate boot image
            return self.generate_boot_image()
            
        except Exception as e:
            self.logger.error(f"Error creating FSBL boot image: {e}")
            return False
    
    def create_zynqmp_boot_image(self, fsbl_path: str, pmufw_path: str, 
                               bitstream_path: str, atf_path: str,
                               uboot_path: str, output_path: str = "boot.bin") -> bool:
        """
        Create a ZynqMP boot image with all components.
        
        Args:
            fsbl_path: Path to FSBL ELF file
            pmufw_path: Path to PMUFW ELF file
            bitstream_path: Path to bitstream file
            atf_path: Path to ATF ELF file
            uboot_path: Path to U-Boot ELF file
            output_path: Output boot image path
            
        Returns:
            True if successful, False otherwise
        """
        try:
            # Verify input files exist
            files_to_check = {
                "FSBL": fsbl_path,
                "PMUFW": pmufw_path,
                "Bitstream": bitstream_path,
                "ATF": atf_path,
                "U-Boot": uboot_path
            }
            
            for name, path in files_to_check.items():
                if not os.path.exists(path):
                    raise BootgenError(f"{name} file not found: {path}")
            
            # Create components for ZynqMP
            components = [
                BootComponent("fsbl", BootComponentType.FSBL, fsbl_path),
                BootComponent("pmufw", BootComponentType.PMUFW, pmufw_path),
                BootComponent("bitstream", BootComponentType.BITSTREAM, bitstream_path),
                BootComponent("atf", BootComponentType.ATF, atf_path),
                BootComponent("uboot", BootComponentType.UBOOT, uboot_path)
            ]
            
            # Update config for ZynqMP
            self.config.output_file = output_path
            self.config.components = components
            self.config.arch = "zynqmp"
            
            # Generate boot image
            return self.generate_boot_image()
            
        except Exception as e:
            self.logger.error(f"Error creating ZynqMP boot image: {e}")
            return False


class VivadoProjectManager:
    """
    Manager for Vivado project operations.
    
    This class provides functionality for working with Vivado projects,
    including generating bitstreams and associating ELF files.
    """
    
    def __init__(self, project_path: str, vivado_path: Optional[str] = None):
        """
        Initialize Vivado project manager.
        
        Args:
            project_path: Path to Vivado project (.xpr file)
            vivado_path: Path to Vivado executable
        """
        self.project_path = Path(project_path)
        self.vivado_path = vivado_path
        self.logger = logging.getLogger(__name__)
        
        if not self.project_path.exists():
            raise BootgenError(f"Vivado project not found: {project_path}")
    
    def _find_vivado_executable(self) -> str:
        """
        Find the Vivado executable.
        
        Returns:
            Path to the Vivado executable
        """
        if self.vivado_path:
            if os.path.exists(self.vivado_path):
                return self.vivado_path
            else:
                raise BootgenError(f"Specified Vivado path not found: {self.vivado_path}")
        
        # Common installation paths for Vivado
        common_paths = [
            # Windows paths
            r"C:\Xilinx\Vivado\*\bin\vivado.exe",
            # Linux paths
            "/opt/Xilinx/Vivado/*/bin/vivado",
            # Generic paths
            "vivado"
        ]
        
        for path_pattern in common_paths:
            if "*" in path_pattern:
                import glob
                matches = glob.glob(path_pattern)
                if matches:
                    return matches[0]
            else:
                try:
                    result = subprocess.run(
                        ["which", path_pattern] if os.name != "nt" else ["where", path_pattern],
                        capture_output=True,
                        text=True,
                        timeout=5
                    )
                    if result.returncode == 0:
                        return path_pattern
                except (subprocess.TimeoutExpired, FileNotFoundError):
                    continue
        
        raise BootgenError(
            "Could not find Vivado executable. "
            "Please ensure Vivado is installed and in PATH, "
            "or specify the Vivado path in configuration."
        )
    
    def generate_bitstream(self, output_dir: Optional[str] = None) -> Optional[str]:
        """
        Generate bitstream for the project.
        
        Args:
            output_dir: Output directory for bitstream
            
        Returns:
            Path to generated bitstream file, or None if failed
        """
        try:
            vivado_path = self._find_vivado_executable()
            self.logger.info(f"Using Vivado: {vivado_path}")
            
            # Create TCL script for bitstream generation
            tcl_script = f"""
# Open project
open_project {self.project_path}
# Update compile order
update_compile_order -fileset sources_1
# Launch synthesis
launch_runs synth_1 -jobs 4
wait_on_run synth_1
# Launch implementation
launch_runs impl_1 -jobs 4
wait_on_run impl_1
# Generate bitstream
launch_runs impl_1 -to_step write_bitstream -jobs 4
wait_on_run impl_1
# Exit
exit
"""
            
            # Write TCL script to temporary file
            with tempfile.NamedTemporaryFile(mode='w', suffix='.tcl', delete=False) as tcl_file:
                tcl_file.write(tcl_script)
                tcl_script_path = tcl_file.name
            
            try:
                # Run Vivado with TCL script
                cmd = [vivado_path, "-mode", "batch", "-source", tcl_script_path]
                
                self.logger.info(f"Running Vivado bitstream generation...")
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=1800)
                
                if result.returncode == 0:
                    # Find generated bitstream
                    project_dir = self.project_path.parent
                    bitstream_pattern = project_dir / "*.runs" / "impl_1" / "*.bit"
                    
                    import glob
                    bitstream_files = glob.glob(str(bitstream_pattern))
                    
                    if bitstream_files:
                        bitstream_path = bitstream_files[0]
                        self.logger.info(f"Bitstream generated: {bitstream_path}")
                        return bitstream_path
                    else:
                        self.logger.error("Bitstream file not found after generation")
                        return None
                else:
                    self.logger.error(f"Vivado bitstream generation failed: {result.stderr}")
                    return None
                    
            finally:
                # Clean up TCL script
                try:
                    os.unlink(tcl_script_path)
                except:
                    pass
            
        except Exception as e:
            self.logger.error(f"Error generating bitstream: {e}")
            return None
    
    def associate_elf_file(self, elf_path: str, target_cpu: str = "ps7_cortexa9_0") -> bool:
        """
        Associate ELF file with the project.
        
        Args:
            elf_path: Path to ELF file
            target_cpu: Target CPU name
            
        Returns:
            True if successful, False otherwise
        """
        try:
            if not os.path.exists(elf_path):
                raise BootgenError(f"ELF file not found: {elf_path}")
            
            vivado_path = self._find_vivado_executable()
            
            # Create TCL script for ELF association
            tcl_script = f"""
# Open project
open_project {self.project_path}
# Add ELF file
add_files -norecurse {elf_path}
# Set properties
set_property SCOPED_TO_REF [get_filesets sources_1] [get_files -of_objects [get_filesets sources_1] {elf_path}]
set_property SCOPED_TO_CELLS {{ {target_cpu} }} [get_files -of_objects [get_filesets sources_1] {elf_path}]
# Update compile order
update_compile_order -fileset sources_1
# Exit
exit
"""
            
            # Write TCL script to temporary file
            with tempfile.NamedTemporaryFile(mode='w', suffix='.tcl', delete=False) as tcl_file:
                tcl_file.write(tcl_script)
                tcl_script_path = tcl_file.name
            
            try:
                # Run Vivado with TCL script
                cmd = [vivado_path, "-mode", "batch", "-source", tcl_script_path]
                
                self.logger.info(f"Associating ELF file: {elf_path}")
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
                
                if result.returncode == 0:
                    self.logger.info("ELF file associated successfully")
                    return True
                else:
                    self.logger.error(f"ELF association failed: {result.stderr}")
                    return False
                    
            finally:
                # Clean up TCL script
                try:
                    os.unlink(tcl_script_path)
                except:
                    pass
            
        except Exception as e:
            self.logger.error(f"Error associating ELF file: {e}")
            return False


def create_bootgen_config_from_dict(config_dict: Dict[str, Any]) -> BootgenConfig:
    """
    Create a BootgenConfig object from a dictionary.
    
    Args:
        config_dict: Dictionary containing configuration parameters
        
    Returns:
        BootgenConfig object
    """
    config = BootgenConfig(
        output_file=config_dict.get('output_file', 'boot.bin'),
        boot_mode=config_dict.get('boot_mode', 'sd'),
        arch=config_dict.get('arch', 'zynqmp'),
        boot_device=config_dict.get('boot_device', 'sd0'),
        bootgen_path=config_dict.get('bootgen_path'),
        verbose=config_dict.get('verbose', False)
    )
    
    # Parse components
    components = []
    for comp_dict in config_dict.get('components', []):
        component = BootComponent(
            name=comp_dict['name'],
            component_type=BootComponentType(comp_dict['type']),
            file_path=comp_dict['file_path'],
            load_address=comp_dict.get('load_address'),
            execution_address=comp_dict.get('execution_address'),
            attributes=comp_dict.get('attributes')
        )
        components.append(component)
    
    config.components = components
    return config


if __name__ == "__main__":
    # Example usage
    logging.basicConfig(level=logging.INFO)
    
    # Create a simple FSBL boot image
    bootgen = XilinxBootgen()
    
    # Example: Create FSBL boot image
    # bootgen.create_fsbl_boot_image(
    #     fsbl_path="fsbl.elf",
    #     bitstream_path="design.bit",
    #     output_path="boot.bin"
    # )
    
    print("Bootgen utility ready for use")
