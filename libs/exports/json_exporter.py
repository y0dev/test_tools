#!/usr/bin/env python3
"""
JSON Export Handler

Handles the generation of JSON files in a structured, easy-to-read format for test results.
Provides comprehensive data export with proper organization and metadata.
"""

import json
import logging
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any, Optional


class JSONExporter:
    """
    JSON export handler for test results and data.
    
    This class provides comprehensive JSON export functionality with:
    - Structured data organization
    - Metadata inclusion
    - Easy-to-read formatting
    - Data validation
    - Error handling
    """
    
    def __init__(self, output_directory: str = "./output/reports"):
        """
        Initialize JSON exporter.
        
        Args:
            output_directory (str): Directory to save JSON files
        """
        self.output_directory = Path(output_directory)
        self.output_directory.mkdir(parents=True, exist_ok=True)
        self.logger = logging.getLogger(__name__)
    
    def export_test_results(self, test_summary: Dict[str, Any], 
                          cycle_data: List[Dict[str, Any]] = None,
                          uart_data: List[Dict[str, Any]] = None,
                          validation_results: List[Dict[str, Any]] = None,
                          filename_prefix: str = "test_results") -> str:
        """
        Export comprehensive test results to JSON format.
        
        Args:
            test_summary (dict): Overall test summary data
            cycle_data (list): Individual cycle execution data
            uart_data (list): UART data collected during tests
            validation_results (list): Pattern validation results
            filename_prefix (str): Prefix for the generated filename
            
        Returns:
            str: Path to the generated JSON file
        """
        timestamp = datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
        filename = f"{filename_prefix}_{timestamp}.json"
        filepath = self.output_directory / filename
        
        self.logger.info(f"Exporting test results to JSON: {filepath}")
        
        try:
            # Create comprehensive data structure
            export_data = self._create_export_structure(
                test_summary, cycle_data, uart_data, validation_results
            )
            
            # Write JSON file with proper formatting
            with open(filepath, 'w', encoding='utf-8') as jsonfile:
                json.dump(export_data, jsonfile, indent=2, ensure_ascii=False)
            
            self.logger.info(f"JSON export completed successfully: {filepath}")
            return str(filepath)
            
        except Exception as e:
            self.logger.error(f"Failed to export JSON: {e}")
            raise
    
    def _create_export_structure(self, test_summary: Dict[str, Any], 
                                cycle_data: List[Dict[str, Any]] = None,
                                uart_data: List[Dict[str, Any]] = None,
                                validation_results: List[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Create structured export data.
        
        Args:
            test_summary (dict): Test summary data
            cycle_data (list): Cycle data
            uart_data (list): UART data
            validation_results (list): Validation results
            
        Returns:
            dict: Structured export data
        """
        export_data = {
            "metadata": {
                "framework_name": "Automated Power Cycle and UART Validation Framework",
                "framework_version": "1.0.0",
                "export_format": "JSON",
                "export_timestamp": datetime.now().isoformat(),
                "export_version": "1.0"
            },
            "test_summary": self._process_test_summary(test_summary),
            "test_data": {
                "cycles": cycle_data or [],
                "uart_data": uart_data or [],
                "validation_results": validation_results or []
            },
            "statistics": self._calculate_statistics(test_summary, cycle_data, validation_results),
            "export_info": {
                "total_records": self._count_total_records(cycle_data, uart_data, validation_results),
                "data_sections": self._get_data_sections(cycle_data, uart_data, validation_results),
                "export_notes": "Generated by Automated Power Cycle and UART Validation Framework"
            }
        }
        
        return export_data
    
    def _process_test_summary(self, test_summary: Dict[str, Any]) -> Dict[str, Any]:
        """Process and enhance test summary data."""
        processed_summary = test_summary.copy()
        
        # Add calculated fields
        if 'success_rate' in processed_summary:
            processed_summary['success_rate_percentage'] = f"{processed_summary['success_rate'] * 100:.2f}%"
        
        if 'duration' in processed_summary:
            processed_summary['duration_formatted'] = self._format_duration(processed_summary['duration'])
        
        # Add status interpretation
        status = processed_summary.get('status', 'UNKNOWN')
        processed_summary['status_interpretation'] = self._interpret_status(status)
        
        return processed_summary
    
    def _calculate_statistics(self, test_summary: Dict[str, Any], 
                            cycle_data: List[Dict[str, Any]] = None,
                            validation_results: List[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Calculate comprehensive statistics."""
        stats = {
            "test_statistics": {
                "total_cycles": test_summary.get('total_cycles', 0),
                "successful_cycles": test_summary.get('successful_cycles', 0),
                "failed_cycles": test_summary.get('failed_cycles', 0),
                "success_rate": test_summary.get('success_rate', 0),
                "duration_seconds": test_summary.get('duration', 0)
            }
        }
        
        # Cycle statistics
        if cycle_data:
            stats["cycle_statistics"] = self._calculate_cycle_statistics(cycle_data)
        
        # Validation statistics
        if validation_results:
            stats["validation_statistics"] = self._calculate_validation_statistics(validation_results)
        
        return stats
    
    def _calculate_cycle_statistics(self, cycle_data: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Calculate cycle-specific statistics."""
        if not cycle_data:
            return {}
        
        durations = [cycle.get('duration', 0) for cycle in cycle_data if cycle.get('duration')]
        voltages = [cycle.get('voltage_measured', 0) for cycle in cycle_data if cycle.get('voltage_measured')]
        
        stats = {
            "total_cycles": len(cycle_data),
            "average_duration": sum(durations) / len(durations) if durations else 0,
            "min_duration": min(durations) if durations else 0,
            "max_duration": max(durations) if durations else 0,
            "average_voltage": sum(voltages) / len(voltages) if voltages else 0,
            "min_voltage": min(voltages) if voltages else 0,
            "max_voltage": max(voltages) if voltages else 0
        }
        
        return stats
    
    def _calculate_validation_statistics(self, validation_results: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Calculate validation-specific statistics."""
        if not validation_results:
            return {}
        
        total_patterns = len(validation_results)
        successful_patterns = sum(1 for result in validation_results if result.get('success', False))
        
        stats = {
            "total_patterns": total_patterns,
            "successful_patterns": successful_patterns,
            "failed_patterns": total_patterns - successful_patterns,
            "success_rate": successful_patterns / total_patterns if total_patterns > 0 else 0
        }
        
        return stats
    
    def _count_total_records(self, cycle_data: List[Dict[str, Any]] = None,
                           uart_data: List[Dict[str, Any]] = None,
                           validation_results: List[Dict[str, Any]] = None) -> int:
        """Count total records across all data sections."""
        count = 0
        count += len(cycle_data) if cycle_data else 0
        count += len(uart_data) if uart_data else 0
        count += len(validation_results) if validation_results else 0
        return count
    
    def _get_data_sections(self, cycle_data: List[Dict[str, Any]] = None,
                          uart_data: List[Dict[str, Any]] = None,
                          validation_results: List[Dict[str, Any]] = None) -> List[str]:
        """Get list of available data sections."""
        sections = []
        if cycle_data:
            sections.append("cycles")
        if uart_data:
            sections.append("uart_data")
        if validation_results:
            sections.append("validation_results")
        return sections
    
    def _format_duration(self, duration_seconds: float) -> str:
        """Format duration in human-readable format."""
        if duration_seconds < 60:
            return f"{duration_seconds:.1f} seconds"
        elif duration_seconds < 3600:
            minutes = duration_seconds / 60
            return f"{minutes:.1f} minutes"
        else:
            hours = duration_seconds / 3600
            return f"{hours:.1f} hours"
    
    def _interpret_status(self, status: str) -> str:
        """Interpret test status."""
        status_map = {
            'PASS': 'Test completed successfully',
            'FAIL': 'Test failed',
            'PARTIAL': 'Test completed with some failures',
            'ERROR': 'Test encountered an error',
            'TIMEOUT': 'Test timed out',
            'INTERRUPTED': 'Test was interrupted by user',
            'UNKNOWN': 'Test status is unknown'
        }
        return status_map.get(status, 'Unknown status')
    
    def export_simple_data(self, data: List[Dict[str, Any]], 
                          filename: str = "data_export.json",
                          metadata: Dict[str, Any] = None) -> str:
        """
        Export simple data to JSON format.
        
        Args:
            data (list): List of dictionaries to export
            filename (str): Output filename
            metadata (dict): Additional metadata to include
            
        Returns:
            str: Path to the generated JSON file
        """
        filepath = self.output_directory / filename
        
        self.logger.info(f"Exporting simple data to JSON: {filepath}")
        
        try:
            export_data = {
                "metadata": {
                    "export_timestamp": datetime.now().isoformat(),
                    "total_records": len(data),
                    "export_format": "JSON"
                },
                "data": data
            }
            
            # Add custom metadata if provided
            if metadata:
                export_data["metadata"].update(metadata)
            
            with open(filepath, 'w', encoding='utf-8') as jsonfile:
                json.dump(export_data, jsonfile, indent=2, ensure_ascii=False)
            
            self.logger.info(f"Simple JSON export completed: {filepath}")
            return str(filepath)
            
        except Exception as e:
            self.logger.error(f"Failed to export simple JSON: {e}")
            raise
    
    def export_cycle_analysis(self, cycle_results: List[Dict[str, Any]], 
                            filename_prefix: str = "cycle_analysis") -> str:
        """
        Export detailed cycle analysis to JSON.
        
        Args:
            cycle_results (list): Detailed cycle analysis data
            filename_prefix (str): Prefix for filename
            
        Returns:
            str: Path to generated JSON file
        """
        timestamp = datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
        filename = f"{filename_prefix}_{timestamp}.json"
        filepath = self.output_directory / filename
        
        self.logger.info(f"Exporting cycle analysis to JSON: {filepath}")
        
        try:
            export_data = {
                "metadata": {
                    "report_type": "Cycle Analysis",
                    "export_timestamp": datetime.now().isoformat(),
                    "total_cycles": len(cycle_results),
                    "framework_version": "1.0.0"
                },
                "cycle_analysis": {
                    "cycles": cycle_results,
                    "statistics": self._calculate_cycle_statistics(cycle_results),
                    "summary": self._create_cycle_summary(cycle_results)
                }
            }
            
            with open(filepath, 'w', encoding='utf-8') as jsonfile:
                json.dump(export_data, jsonfile, indent=2, ensure_ascii=False)
            
            self.logger.info(f"Cycle analysis JSON export completed: {filepath}")
            return str(filepath)
            
        except Exception as e:
            self.logger.error(f"Failed to export cycle analysis JSON: {e}")
            raise
    
    def _create_cycle_summary(self, cycle_results: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Create cycle summary information."""
        if not cycle_results:
            return {}
        
        successful_cycles = [cycle for cycle in cycle_results if cycle.get('status') == 'PASS']
        failed_cycles = [cycle for cycle in cycle_results if cycle.get('status') == 'FAIL']
        
        summary = {
            "total_cycles": len(cycle_results),
            "successful_cycles": len(successful_cycles),
            "failed_cycles": len(failed_cycles),
            "success_rate": len(successful_cycles) / len(cycle_results) if cycle_results else 0,
            "average_duration": sum(cycle.get('duration', 0) for cycle in cycle_results) / len(cycle_results),
            "total_duration": sum(cycle.get('duration', 0) for cycle in cycle_results)
        }
        
        return summary
    
    def export_configuration(self, config: Dict[str, Any], 
                           filename: str = "configuration_export.json") -> str:
        """
        Export configuration data to JSON.
        
        Args:
            config (dict): Configuration data
            filename (str): Output filename
            
        Returns:
            str: Path to generated JSON file
        """
        filepath = self.output_directory / filename
        
        self.logger.info(f"Exporting configuration to JSON: {filepath}")
        
        try:
            export_data = {
                "metadata": {
                    "export_type": "Configuration",
                    "export_timestamp": datetime.now().isoformat(),
                    "framework_version": "1.0.0"
                },
                "configuration": config
            }
            
            with open(filepath, 'w', encoding='utf-8') as jsonfile:
                json.dump(export_data, jsonfile, indent=2, ensure_ascii=False)
            
            self.logger.info(f"Configuration JSON export completed: {filepath}")
            return str(filepath)
            
        except Exception as e:
            self.logger.error(f"Failed to export configuration JSON: {e}")
            raise


# Example usage
if __name__ == "__main__":
    # Setup logging
    logging.basicConfig(level=logging.INFO)
    
    # Create exporter
    exporter = JSONExporter()
    
    # Sample test data
    test_summary = {
        'test_name': 'Sample Test',
        'start_time': '2024-01-15 10:00:00',
        'end_time': '2024-01-15 10:05:00',
        'duration': 300,
        'total_cycles': 3,
        'successful_cycles': 2,
        'failed_cycles': 1,
        'success_rate': 0.67,
        'status': 'PARTIAL'
    }
    
    cycle_data = [
        {
            'cycle_number': 1,
            'start_time': '2024-01-15 10:00:00',
            'end_time': '2024-01-15 10:01:00',
            'duration': 60,
            'status': 'PASS',
            'on_time': 30,
            'off_time': 30,
            'voltage_setting': 5.0,
            'voltage_measured': 4.98
        },
        {
            'cycle_number': 2,
            'start_time': '2024-01-15 10:01:00',
            'end_time': '2024-01-15 10:02:00',
            'duration': 60,
            'status': 'PASS',
            'on_time': 30,
            'off_time': 30,
            'voltage_setting': 5.0,
            'voltage_measured': 5.01
        },
        {
            'cycle_number': 3,
            'start_time': '2024-01-15 10:02:00',
            'end_time': '2024-01-15 10:03:00',
            'duration': 60,
            'status': 'FAIL',
            'on_time': 30,
            'off_time': 30,
            'voltage_setting': 5.0,
            'voltage_measured': 0.0,
            'error_message': 'Power supply communication error'
        }
    ]
    
    validation_results = [
        {
            'pattern_name': 'boot_ready',
            'pattern_type': 'regex',
            'success': True,
            'matched_data': 'READY',
            'expected': 'READY',
            'message': 'Pattern matched successfully',
            'timestamp': '2024-01-15 10:00:30'
        },
        {
            'pattern_name': 'voltage_check',
            'pattern_type': 'numeric_range',
            'success': False,
            'matched_data': '0.0',
            'expected': '4.8-5.2',
            'message': 'Voltage out of range',
            'timestamp': '2024-01-15 10:02:30'
        }
    ]
    
    # Export test results
    json_file = exporter.export_test_results(test_summary, cycle_data, None, validation_results)
    print(f"JSON export completed: {json_file}")
    
    # Export cycle analysis
    analysis_file = exporter.export_cycle_analysis(cycle_data)
    print(f"Cycle analysis export completed: {analysis_file}")
    
    # Export simple data
    simple_file = exporter.export_simple_data(cycle_data, "simple_cycles.json")
    print(f"Simple data export completed: {simple_file}")
